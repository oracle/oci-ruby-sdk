# Copyright (c) 2016, 2023, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: v1
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Settings related to Time-Based One-Time Passcodes (TOTP), such as hashing algo, totp time step, passcode length, and so on
  #
  # **SCIM++ Properties:**
  #  - idcsSearchable: false
  #  - multiValued: false
  #  - mutability: readWrite
  #  - required: true
  #  - returned: default
  #  - type: complex
  #  - uniqueness: none
  class IdentityDomains::Models::AuthenticationFactorSettingsTotpSettings
    HASHING_ALGORITHM_ENUM = [
      HASHING_ALGORITHM_SHA1 = 'SHA1'.freeze,
      HASHING_ALGORITHM_SHA256 = 'SHA256'.freeze,
      HASHING_ALGORITHM_SHA384 = 'SHA384'.freeze,
      HASHING_ALGORITHM_SHA512 = 'SHA512'.freeze,
      HASHING_ALGORITHM_MD5 = 'MD5'.freeze,
      HASHING_ALGORITHM_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # **[Required]** The hashing algorithm to be used to calculate a One-Time Passcode. By default, the system uses SHA1.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :hashing_algorithm

    # **[Required]** Exact length of the One-Time Passcode that the system should generate
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 10
    #  - idcsMinValue: 4
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :passcode_length

    # **[Required]** The duration of time (in days) after which the shared secret has to be refreshed
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 999
    #  - idcsMinValue: 30
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :key_refresh_interval_in_days

    # **[Required]** Time (in secs) to be used as the time step
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 300
    #  - idcsMinValue: 30
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :time_step_in_secs

    # **[Required]** The tolerance/step-size that the system should use when validating a One-Time Passcode
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 3
    #  - idcsMinValue: 2
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :time_step_tolerance

    # **[Required]** The period of time (in minutes) for which a One-Time Passcode that the system sends by Short Message Service (SMS) or by voice remains valid
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 60
    #  - idcsMinValue: 2
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :sms_otp_validity_duration_in_mins

    # **[Required]** The period of time (in seconds) that a JSON Web Token (JWT) is valid
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 99999
    #  - idcsMinValue: 30
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :jwt_validity_duration_in_secs

    # **[Required]** Exact length of the Short Message Service (SMS) One-Time Passcode
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 10
    #  - idcsMinValue: 4
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :sms_passcode_length

    # **[Required]** The period of time (in minutes) that a one-time passcode remains valid that the system sends by email.
    #
    # **Added In:** 18.1.2
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 60
    #  - idcsMinValue: 2
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :email_otp_validity_duration_in_mins

    # **[Required]** Exact length of the email one-time passcode.
    #
    # **Added In:** 18.1.2
    #
    # **SCIM++ Properties:**
    #  - idcsMaxValue: 10
    #  - idcsMinValue: 4
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: true
    #  - returned: default
    #  - type: integer
    #  - uniqueness: none
    # @return [Integer]
    attr_accessor :email_passcode_length

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'hashing_algorithm': :'hashingAlgorithm',
        'passcode_length': :'passcodeLength',
        'key_refresh_interval_in_days': :'keyRefreshIntervalInDays',
        'time_step_in_secs': :'timeStepInSecs',
        'time_step_tolerance': :'timeStepTolerance',
        'sms_otp_validity_duration_in_mins': :'smsOtpValidityDurationInMins',
        'jwt_validity_duration_in_secs': :'jwtValidityDurationInSecs',
        'sms_passcode_length': :'smsPasscodeLength',
        'email_otp_validity_duration_in_mins': :'emailOtpValidityDurationInMins',
        'email_passcode_length': :'emailPasscodeLength'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'hashing_algorithm': :'String',
        'passcode_length': :'Integer',
        'key_refresh_interval_in_days': :'Integer',
        'time_step_in_secs': :'Integer',
        'time_step_tolerance': :'Integer',
        'sms_otp_validity_duration_in_mins': :'Integer',
        'jwt_validity_duration_in_secs': :'Integer',
        'sms_passcode_length': :'Integer',
        'email_otp_validity_duration_in_mins': :'Integer',
        'email_passcode_length': :'Integer'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :hashing_algorithm The value to assign to the {#hashing_algorithm} property
    # @option attributes [Integer] :passcode_length The value to assign to the {#passcode_length} property
    # @option attributes [Integer] :key_refresh_interval_in_days The value to assign to the {#key_refresh_interval_in_days} property
    # @option attributes [Integer] :time_step_in_secs The value to assign to the {#time_step_in_secs} property
    # @option attributes [Integer] :time_step_tolerance The value to assign to the {#time_step_tolerance} property
    # @option attributes [Integer] :sms_otp_validity_duration_in_mins The value to assign to the {#sms_otp_validity_duration_in_mins} property
    # @option attributes [Integer] :jwt_validity_duration_in_secs The value to assign to the {#jwt_validity_duration_in_secs} property
    # @option attributes [Integer] :sms_passcode_length The value to assign to the {#sms_passcode_length} property
    # @option attributes [Integer] :email_otp_validity_duration_in_mins The value to assign to the {#email_otp_validity_duration_in_mins} property
    # @option attributes [Integer] :email_passcode_length The value to assign to the {#email_passcode_length} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.hashing_algorithm = attributes[:'hashingAlgorithm'] if attributes[:'hashingAlgorithm']

      raise 'You cannot provide both :hashingAlgorithm and :hashing_algorithm' if attributes.key?(:'hashingAlgorithm') && attributes.key?(:'hashing_algorithm')

      self.hashing_algorithm = attributes[:'hashing_algorithm'] if attributes[:'hashing_algorithm']

      self.passcode_length = attributes[:'passcodeLength'] if attributes[:'passcodeLength']

      raise 'You cannot provide both :passcodeLength and :passcode_length' if attributes.key?(:'passcodeLength') && attributes.key?(:'passcode_length')

      self.passcode_length = attributes[:'passcode_length'] if attributes[:'passcode_length']

      self.key_refresh_interval_in_days = attributes[:'keyRefreshIntervalInDays'] if attributes[:'keyRefreshIntervalInDays']

      raise 'You cannot provide both :keyRefreshIntervalInDays and :key_refresh_interval_in_days' if attributes.key?(:'keyRefreshIntervalInDays') && attributes.key?(:'key_refresh_interval_in_days')

      self.key_refresh_interval_in_days = attributes[:'key_refresh_interval_in_days'] if attributes[:'key_refresh_interval_in_days']

      self.time_step_in_secs = attributes[:'timeStepInSecs'] if attributes[:'timeStepInSecs']

      raise 'You cannot provide both :timeStepInSecs and :time_step_in_secs' if attributes.key?(:'timeStepInSecs') && attributes.key?(:'time_step_in_secs')

      self.time_step_in_secs = attributes[:'time_step_in_secs'] if attributes[:'time_step_in_secs']

      self.time_step_tolerance = attributes[:'timeStepTolerance'] if attributes[:'timeStepTolerance']

      raise 'You cannot provide both :timeStepTolerance and :time_step_tolerance' if attributes.key?(:'timeStepTolerance') && attributes.key?(:'time_step_tolerance')

      self.time_step_tolerance = attributes[:'time_step_tolerance'] if attributes[:'time_step_tolerance']

      self.sms_otp_validity_duration_in_mins = attributes[:'smsOtpValidityDurationInMins'] if attributes[:'smsOtpValidityDurationInMins']

      raise 'You cannot provide both :smsOtpValidityDurationInMins and :sms_otp_validity_duration_in_mins' if attributes.key?(:'smsOtpValidityDurationInMins') && attributes.key?(:'sms_otp_validity_duration_in_mins')

      self.sms_otp_validity_duration_in_mins = attributes[:'sms_otp_validity_duration_in_mins'] if attributes[:'sms_otp_validity_duration_in_mins']

      self.jwt_validity_duration_in_secs = attributes[:'jwtValidityDurationInSecs'] if attributes[:'jwtValidityDurationInSecs']

      raise 'You cannot provide both :jwtValidityDurationInSecs and :jwt_validity_duration_in_secs' if attributes.key?(:'jwtValidityDurationInSecs') && attributes.key?(:'jwt_validity_duration_in_secs')

      self.jwt_validity_duration_in_secs = attributes[:'jwt_validity_duration_in_secs'] if attributes[:'jwt_validity_duration_in_secs']

      self.sms_passcode_length = attributes[:'smsPasscodeLength'] if attributes[:'smsPasscodeLength']

      raise 'You cannot provide both :smsPasscodeLength and :sms_passcode_length' if attributes.key?(:'smsPasscodeLength') && attributes.key?(:'sms_passcode_length')

      self.sms_passcode_length = attributes[:'sms_passcode_length'] if attributes[:'sms_passcode_length']

      self.email_otp_validity_duration_in_mins = attributes[:'emailOtpValidityDurationInMins'] if attributes[:'emailOtpValidityDurationInMins']

      raise 'You cannot provide both :emailOtpValidityDurationInMins and :email_otp_validity_duration_in_mins' if attributes.key?(:'emailOtpValidityDurationInMins') && attributes.key?(:'email_otp_validity_duration_in_mins')

      self.email_otp_validity_duration_in_mins = attributes[:'email_otp_validity_duration_in_mins'] if attributes[:'email_otp_validity_duration_in_mins']

      self.email_passcode_length = attributes[:'emailPasscodeLength'] if attributes[:'emailPasscodeLength']

      raise 'You cannot provide both :emailPasscodeLength and :email_passcode_length' if attributes.key?(:'emailPasscodeLength') && attributes.key?(:'email_passcode_length')

      self.email_passcode_length = attributes[:'email_passcode_length'] if attributes[:'email_passcode_length']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] hashing_algorithm Object to be assigned
    def hashing_algorithm=(hashing_algorithm)
      # rubocop:disable Style/ConditionalAssignment
      if hashing_algorithm && !HASHING_ALGORITHM_ENUM.include?(hashing_algorithm)
        OCI.logger.debug("Unknown value for 'hashing_algorithm' [" + hashing_algorithm + "]. Mapping to 'HASHING_ALGORITHM_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @hashing_algorithm = HASHING_ALGORITHM_UNKNOWN_ENUM_VALUE
      else
        @hashing_algorithm = hashing_algorithm
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        hashing_algorithm == other.hashing_algorithm &&
        passcode_length == other.passcode_length &&
        key_refresh_interval_in_days == other.key_refresh_interval_in_days &&
        time_step_in_secs == other.time_step_in_secs &&
        time_step_tolerance == other.time_step_tolerance &&
        sms_otp_validity_duration_in_mins == other.sms_otp_validity_duration_in_mins &&
        jwt_validity_duration_in_secs == other.jwt_validity_duration_in_secs &&
        sms_passcode_length == other.sms_passcode_length &&
        email_otp_validity_duration_in_mins == other.email_otp_validity_duration_in_mins &&
        email_passcode_length == other.email_passcode_length
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [hashing_algorithm, passcode_length, key_refresh_interval_in_days, time_step_in_secs, time_step_tolerance, sms_otp_validity_duration_in_mins, jwt_validity_duration_in_secs, sms_passcode_length, email_otp_validity_duration_in_mins, email_passcode_length].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
